<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>但行好事，莫问前程</title>
  <subtitle>Web Developer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-19T07:01:44.816Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>silence_wh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>防抖动、节流阀与rAF</title>
    <link href="http://yoursite.com/2017/06/19/%E9%98%B2%E6%8A%96%E5%8A%A8%E3%80%81%E8%8A%82%E6%B5%81%E9%98%80%E4%B8%8ErAF/"/>
    <id>http://yoursite.com/2017/06/19/防抖动、节流阀与rAF/</id>
    <published>2017-06-19T14:57:18.000Z</published>
    <updated>2017-06-19T07:01:44.816Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>在 web 开发中，经常会对一些事件进行监听处理，从而达到我们需要的一些效果。但是某些事件触发特别频繁，如浏览器窗口的 resize 事件以及页面的滚动事件。如此频繁的事件监听以及处理函数的多次执行，势必会带来性能上不必要的损失和欠佳的用户体验。</p>
<p>因此，今天就初探一下类似问题的解决办法：防抖动（Debounce ）、节流阀（Throttle）和 requestAnimationFrame。</p>
<h4 id="2-防抖动（Debounce）"><a href="#2-防抖动（Debounce）" class="headerlink" title="2.防抖动（Debounce）"></a>2.防抖动（Debounce）</h4><p>简单来说，防抖动技术就是把触发非常频繁的事件合并成一次执行。</p>
<p>先看一下代码实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> timeID = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// 首先是清空定时器</span></div><div class="line">    clearTimeout(timeID);</div><div class="line">    <span class="comment">// 延迟 wait ms后执行真正的事件处理函数</span></div><div class="line">    timeID = setTimeOut(func, wait);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hanlder</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hanlde the scroll event.'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(hanlder, <span class="number">400</span>));</div></pre></td></tr></table></figure>
<p>简要解释一下，如果在400ms内连续触发 scroll 事件，那么真正的事件处理是不会执行的。只有当快速的事件触发停止以后，处理函数才会执行，也就是说 debounce 函数将多次的事件触发合并成了一次。</p>
<h4 id="3-节流阀（Throttle）"><a href="#3-节流阀（Throttle）" class="headerlink" title="3.节流阀（Throttle）"></a>3.节流阀（Throttle）</h4><p>节流函数，只允许一个函数在规定的时间内执行一次。</p>
<p>它和防抖动最大的区别就是，节流函数是不管事件触发有多频繁，都会保证在规定事件内必须执行一次真正的事件处理函数。因此，有些场景下，就不能够使用防抖动技术，转而用节流阀代替。</p>
<p>比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流阀技术来实现。代码实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> timeout,</div><div class="line">      context,</div><div class="line">      args,</div><div class="line">      startTime = <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>());</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> curTime = <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>());</div><div class="line">    <span class="keyword">var</span> remaining = wait - (curTime - startTime);</div><div class="line">    context = <span class="keyword">this</span>;</div><div class="line">    args = <span class="built_in">arguments</span>;</div><div class="line">    </div><div class="line">    clearTimeout(timeout);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(remaining &lt;= <span class="number">0</span>)&#123;</div><div class="line">      func.apply(context, args);</div><div class="line">      startTime = <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>());</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      timeout = setTimeout(func, remaining);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="4-requestAnimationFrame"><a href="#4-requestAnimationFrame" class="headerlink" title="4.requestAnimationFrame"></a>4.requestAnimationFrame</h4><blockquote>
<p><strong>window.requestAnimationFrame() </strong>方法告诉浏览器您希望执行动画，并请求浏览器调用指定的函数在下一次重绘之前更新动画。该方法将在重绘之前调用的回调作为参数。</p>
<p>如果你想做逐帧动画的时候，你应该用这个方法。这就要求你的动画函数执行会先于浏览器重绘动作。通常来说，被调用的频率是每秒60次，但是一般会遵循W3C标准规定的频率。如果是后台标签页面，重绘频率则会大大降低。</p>
</blockquote>
<p>代码实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">timeStamp</span>)</span>&#123;</div><div class="line">  <span class="comment">// 执行动画一帧所需要的计算工作</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">requestAnimationFrame(update)</div></pre></td></tr></table></figure>
<p>回调函数会被传入一个时间戳作为参数，该参数指示出回调函数将被触发的时间。</p>
<p>简单来说 rAF 会在浏览器渲染的下一帧执行动画所需的计算操作，而且执行的频率与显示器的刷新率保持一致，</p>
<p>这样就避免了我们使用定时器时由于指定的间隔时间太长或太短引起的动画掉帧或卡顿的问题。</p>
<p>浏览器兼容方面，IE 10.0及以上支持。</p>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p>第一次写博客，自我感觉对于技术的剖析很浅，没有达到自己理想的效果。慢慢来吧，再接再厉，参考文章列表里的都是一些非常优秀的文章，大家可以仔细阅读。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://github.com/chokcoco/cnblogsArticle/issues/12" target="_blank" rel="external">【前端性能】高性能滚动 scroll 及页面渲染优化</a></li>
<li><a href="http://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/" target="_blank" rel="external">实例解析防抖动（Debouncing）和节流阀（Throttling）</a></li>
<li><a href="http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering" target="_blank" rel="external">Javascript高性能动画与页面渲染</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h4&gt;&lt;p&gt;在 web 开发中，经常会对一些事件进行监听处理，从而达到我们需要的一些效果。但是某些事件触发特别频繁，如浏览器窗口的 re
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>First One</title>
    <link href="http://yoursite.com/2017/06/08/First-One/"/>
    <id>http://yoursite.com/2017/06/08/First-One/</id>
    <published>2017-06-07T16:18:28.000Z</published>
    <updated>2017-06-07T08:19:15.461Z</updated>
    
    <content type="html"><![CDATA[<p>博客初始搭建完成，以后会在这里写一些技术上的知识学习以及工作中的踩坑记录。<br>Keep Moving.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客初始搭建完成，以后会在这里写一些技术上的知识学习以及工作中的踩坑记录。&lt;br&gt;Keep Moving.&lt;/p&gt;

    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
